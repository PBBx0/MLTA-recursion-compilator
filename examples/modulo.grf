id = projector<0, 1>
//id(x) -> x

one_way_zero = recursion<zero, projector<1, 2>>
// тождественный ноль как функция валентности 1

//one_way_zero(0) -> 0
//one_way_zero(x + 1) 
//		-> projector<1, 2>(x, one_way_zero(x)) 
//				-> one_way_zero(x)
//						-> 0



minus_one = recursion<zero, projector<0, 2>>
// minus_one(a) = [a == 0 ? 0 : a - 1]

//minus_one(0) -> 0
//minus_one(x + 1)
//		-> projector<0, 2>(x, minus_one(x))
//				-> x




mod_minus = recursion<minus_one, projector<1, 3>>
//mod_minus(m, 0)
//		-> minus_one(m)
//				-> [m > 0 ? m - 1 : 0]
//mod_minus(x, y + 1)
//		-> projector<1, 3>(x, y, mod_minus(x, y))
//				-> y

// mod_minus(m, a) = [a == 0 ? m - 1 : a - 1]
// Для m > 0 и a in [0, m] работает ожидаемым способом




f = recursion<one_way_zero, composition<mod_minus, projector<0, 3>, projector<2, 3>>>
// f(x, k) = [k == 0 ? 0 : x - k] = (x - k) mod x
// Для x > 0 и k in [0, x] работает ожидаемым способом
// mod_minus нужен только в переходе от f(x, 0) к f(x, 1), в остальных местах можно было бы обойтись minus_one

//f(x, 0) -> 0
//f(x, y + 1)
//		-> composition<mod_minus, projector<0, 3>, projector<2, 3>>(x, y, f(x, y))
//				-> mod_minus(x, f(x, y))
//						-> f(x, y) - 1 (mod x)





f2 = composition<f, projector<0, 2>, f>
// f2(x, y) = [x == y ? 0 : y]
// Работает ожидаемым способом для y in [0, x]
// на этом отрезке эквивалентно (y mod x)

//f2(x, y)
//		-> f(x, f(x, y))
//				-> f(x, (x - y) mod x)
//						-> (x - (x - y) mod x) mod x
//								-> [y == 0 || y == x ? 0 : y]


third_plus_one = composition<succcessor, projector<2, 3>>
//third_plus_one(x, y, z) -> z + 1

modulo = recursion<one_way_zero, composition<f2, projector<0, 3>, third_plus_one>>
// modulo(x, y) = y mod x
// Работает ожидаемым способом для x > 0

//modulo(x, 0) -> 0
//modulo(x, y + 1)
//		-> composition<f2, projector<0, 3>, third_plus_one>(x, y, modulo(x, y))
//				-> f2(x, modulo(x, y) + 1)
//						-> [modulo(x, y) == x - 1 ? 0 : modulo(x, y) + 1]

modulo