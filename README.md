# Compilator for general recursive functions
Хотим создать синтаксис для написания кода на общерекурсивных функций и компилятор, обрабатывающий этот синтаксис.

## Syntax
Всё есть натуральное число или NaN. (0 натуральный). Работаем только с функциями $f : \mathbb{N}^k \longrightarrow \mathbb{N}$.

У каждой функции фиксированная валентность, известная в compile-time.

Каждая функция получена одним из следующих способов:

- `zero`
	Тождественный ноль нулевой валентности 
	$$h() = 0$$

- `successor`
	Функция следования валентности 1: 
	$$h(x) = x + 1$$

- `proector<i, n>` $0 \le i \lt n$
	Функция-проектор валентности $n$: 
	$$h(x_1, x_2, \ldots, x_n) = x_i$$

- `composition<f, g_1, ..., g_m`
	Валентность $f$ должна равняться $m$, валентность всех $g_i$ должна быть одинакова. Пусть она равна $k$.
	Тогда валентность итоговой функции тоже $k$:
	$$h(x_1, \ldots, x_k) = f(g_1(x_1, \ldots, x_k), \ldots, g_m(x_1, \ldots, x_k))$$

- `recursion<f, g>`
	Если валентность $f$ равна $n$, то валентность $g$ должна быть равна $n + 2$ и валентность итоговой функции $n + 1$:
	$$h(x_1, \ldots, x_n, 0) = f(x_1, \ldots, x_n)$$
	$$h(x_1, \ldots, x_n, y + 1) = g(x_1, \ldots, x_n, y, h(x_1, \ldots, x_n, y))$$

- `argmin<f>`
	Если валентность $f$ равна $n + 1$, то валентность итоговой функции $n$:
	$$h(x_1, \ldots, x_n) = \min \\{ y | f(x_1, \ldots, x_n, y) = 0 \\}$$
